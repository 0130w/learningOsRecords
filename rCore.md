# rCore学习笔记

## 目录

- [rCore学习笔记](#rcore学习笔记)
  - [目录](#目录)
  - [Chapter 0](#chapter-0)
  - [Chapter 1](#chapter-1)
    - [平台与目标三元组](#平台与目标三元组)
  - [Chapter 2](#chapter-2)
    - [特权级机制](#特权级机制)
      - [特权级的软硬件协同设计](#特权级的软硬件协同设计)
      - [RISC-V特权级架构](#risc-v特权级架构)
        - [RISC-V异常一览表](#risc-v异常一览表)
  - [Chapter 4](#chapter-4)
  - [Chapter 5](#chapter-5)
  - [多次使用命令记录](#多次使用命令记录)

## Chapter 0

配置一下环境，然而我的ubuntu物理机上面的VSCode的Extension根本打不开，准备回到我忠实的Vim

## Chapter 1

这个图还挺好的，一眼就感觉挺清晰的

![app-software-stack](./image/app-software-stack.png)

### 平台与目标三元组

目标三元组是这样的一种概念：三元组的第一个元素描述了CPU的指令集，第二个元素描述了CPU的制造厂商，第三个元素描述了程序运行的操作系统(有时候还会带上运行时的标准库)，格式如下

```diff
arch-ventor-os
```

在Terminal中，我们可以通过如下的指令来看rust程序运行时的环境目标三元组

```shell
rust --version --verbose
```

然后我们要做的是把这个`Hello World!`程序移到一个裸机环境中，这就意味着我们不再有系统调用，也不再有标准库的支持，我们采取以下方式让程序在裸机环境下编译

```shell
cargo run --target riscv64gc-unknown-none-elf
```

由于我们的`println!`是`Rust`的标准库提供的，标准库又是基于系统调用实现的，这里自然就不能用了

## Chapter 2

Batch System的核心思想：
将多个程序打包到一起输入计算机；当一个程序运行结束之后，计算机**自动**执行下一个程序

**特权级**机制：
  功能： 实现用户态和内核态的隔离

> 应用程序难免出错，为了不让一个程序的错误而导致整个操作系统无法运行，CPU实现了用于**保护操作系统不受程序破坏的机制**：特权级机制

### 特权级机制

#### 特权级的软硬件协同设计

实现特权级机制的根本原因在于应用程序运行时的安全性不可充分信任

当操作系统和应用程序以库的形式连接在一起，构成一个整体来执行的时候，由于操作系统的服务被频繁调用，操作系统中的错误可能会被较快的发现，但应用程序本身的问题可能是经过了一段时间之后才会被发现。由于两者在执行的时候通过编译器形成了一个单一的执行程序来执行，因此即使是应用程序的问题，也会导致操作系统无法使用从而使得整个计算机系统出问题:(

针对这个问题，科学家和工程师们想到的办法是：
  让相对安全可靠的操作系统运行在一个受硬件保护的安全执行环境中，不受到应用程序的破坏；让应用程序运行在另外一个执行环境中，在这个执行环境中运行的程序无法破坏操作系统

为了确保操作系统的安全，对应用程序而言，我们要对其能够执行的操作加上一些限制：
- 应用程序不能访问任意的地址空间
- 应用程序不能执行某些可能会破坏计算机系统的指令

我们还需要保证应用程序能够得到操作系统的服务，即应用程序和操作系统还需要有交互的手段使得**低特权级**软件只能做**高特权级**软件允许它做的，超出了这个范围的就必须要寻求高特权级软件的帮助，那么这样，**高特权级**软件就成为**低特权级**软件的执行环境的重要组成部分

为了实现这样的特权级机制，需要进行软硬件协同设计。一个比较简洁的方法是，处理器设置两个不同的安全等级的执行环境：
 - 用户态特权级的执行环境
 - 内核态特权级的执行环境
然后明确地指出可能破坏计算机系统的内核态特权级指令子集，规定**内核态特权级指令子集**中的指令只能在内核态特权级的执行环境中执行

处理器在执行指令之前需要进行特权级安全检查，如果在用户态执行环境中执行了内核态特权级的指令，就会产生异常。

为了让应用程序获得操作系统的函数服务，我们可以直接调用操作系统中的函数(如`call`或`ret`指令或指令组合)，但这样做有一个问题，我们直接调用操作系统中的函数就会绕开硬件的特权级检查，从而可能导致安全漏洞

为了在不绕开硬件的特权级检查的情况下实现让应用程序获得操作系统的函数服务，可以设计新的机器指令：
- 执行环境调用(Execution Environment Call: `ecall`):具有从用户态到内核态到执行环境切换能力的函数调用指令(应用程序使用)
- 执行环境返回(Execution Environment return: `eret`):具有从内核态到用户态到执行环境切换能力的函数调用指令(操作系统使用)

当指令集中有了这样的机器指令，操作系统需要进行一些配合：
- 操作系统需要提供相应的功能代码，能够在执行`eret`之前准备和恢复用户态执行程序的上下文
- 应用程序执行了`ecall`指令之后，需要检查应用程序的系统调用的参数，确保这些参数不会破坏操作系统

#### RISC-V特权级架构

RISC-V架构中一共定义了4种特权级：

!TODO

级别的数值越大，特权级越高，掌控硬件的能力越强，在CPU硬件层面，只有`M`模式是必须存在的

> `SEE`:Supervisor Execution Environment
> 比如`Bootloader-RustSBI`，负责加载操作系统的软件就运行在这个环境上

执行环境的功能：
- 执行它支持的上层软件之前进行一些初始化功能
- 对上层软件的执行进行监控管理
> 监控管理：执行的时候出现了一些异常/特殊情况，导致需要用到执行环境中提供的功能，因此需要暂停上层软件的执行，转而去运行执行环境的代码。由于上层的软件和执行环境被设计为不同的模式，这个过程也往往(**不一定?**)伴随着CPU的特权级切换。当执行环境中的代码运行结束后，我们需要回到上层软件暂停的位置继续执行。

在RISC-V架构中，这种与常规的控制流(顺序、循环、分支、函数调用)不同的**异常控制流**被称为**异常**

用户态应用直接触发从用户态到内核态到异常的原因总体可以分为两种：
- 用户态软件为了获取内核态操作系统的服务功能而执行特殊指令
- 用户态执行某条指令期间产生了错误并被CPU检测到

> 为了与其他**非有意为之的异常**区分，会把`Breakpoint`和`Environment call`两种异常这种**有意为之的异常**称为**Trap**指令

##### RISC-V异常一览表

Trap指令是通过在上层软件中执行特定的指令触发的

`ecall`是一类很特殊的Trap类指令，不同特权级之间的接口正是基于这种指令实现的，不同模式下软件的接口被称为是二进制接口：

- `ABI`：又叫`System Call`，应用程序二进制接口
- `SBI`：`Supervisor Binary Interface`

这种接口叫做二进制接口的原因在于，它其实是`机器/汇编指令`级别的接口，这是因为各种模式下的软件可以用不同的编程语言实现，为了使接口能够满足跨高级语言的通用性和灵活性的特性，这些接口需要下降到底层


## Chapter 4

解析两个关键的函数

```rust
pub fn translated_byte_buffer
```

在`memory_set`里面，创建了内核空间


## Chapter 5

1. `fork`系统调用

```rust
pub fn sys_fork() -> isize;
```
由当前进程`fork`出一个子进程，对于子进程返回0，非子进程返回子进程的`PID`

2. `exec`系统调用

```rust
pub fn sys_exec(path: &str) -> isize;
```
`path`为需要加载的可执行文件的名字，`path`需要以`\0`结尾，功能为给当前进程的地址空间加载一个特定的可执行文件，返回用户态后执行，如果找不到该可执行文件，则返回`-1`，否则不应该返回

3. `waitpid`系统调用

```rust
pub fn sys_waitpid(pid: isize, exit_code: *mut i32) -> isize;
```
功能:当前进程等待一个子进程变成僵尸进程，回收其全部资源并收集其返回值
参数:`pid`表示等待的子进程的`ID`，如果为`-1`表示等待任意一个子进程;`exit_code`表示保存子进程返回值的地址，如果这个地址为`0`则表示不必保存
返回值:如果要等待的进程不存在则返回`-1`，如果要等待的子进程均未结束则返回`-2`?否则返回结束的子进程的`ID`

`sys_waitpid`在用户库中被封装成两个不同的`API`
- `wait(exit_code: &mut i32)` 用于等待任意一个进程
- `waitpid(pid: usize, exit_code: &mut i32)` 用于等待`ID`为`pid`的子进程结束

4. `sys_read`系统调用

```rust
pub fn sys_read(fd: usize, buffer: &mut [u8]) -> isize{
  ...
}
```
`fd`为待读文件的文件描述符，`buffer`切片给出了缓冲区
错误则返回`-1`，否则返回实际读入的字节数

5.  `get_app_data_by_name(name: &str) -> Option<&' static [u8]>`

这个函数能够通过`app`的名字来查找`ELF`数据

6.  `list_apps()`打印出所有可用的应用

同一时间存在的所有进程都有一个自己的进程标识符，它们是互不相同的整数。在实验中抽象为
`pub struct PidHandle(pub usize)`

简单栈式分配策略的进程标识符分配器`PidAllocator`，并将其实例化为`PID_ALLOCATOR`

想要得到一个`PidHandle`，我们可以通过全局接口`pid_alloc`

在内核栈`KernelStack`中保留着其所属进程`pid`

有如下函数和方法

## 多次使用命令记录

```shell
file <elf file>
```
用于分析`elf`可执行文件格式

```shell
rust-readobj -h <elf file>
```
用于读取文件头信息，比如可以看某个文件的开始地址

```shell
rust-objdump -arguments <elf file>
```
用于反汇编导出汇编程序
